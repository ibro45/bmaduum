// Package claude provides types and functionality for interacting with the Claude CLI.
//
// This package handles spawning Claude as a subprocess, parsing its streaming JSON
// output, and converting raw events into a convenient structured format.
//
// Key types:
//   - [Executor]: Interface for running Claude CLI commands
//   - [Parser]: Interface for parsing streaming JSON output
//   - [Event]: Parsed event with convenience methods for common checks
//   - [Usage]: Token usage information from Claude API
//
// For testing, use [MockExecutor] which implements [Executor] without spawning
// real processes.
package claude

import "encoding/json"

// Usage represents token usage from Claude API.
//
// This structure appears in both assistant message events (per-message usage)
// and result events (total usage for the session).
type Usage struct {
	// InputTokens is the number of tokens sent to Claude.
	InputTokens int `json:"input_tokens"`

	// OutputTokens is the number of tokens generated by Claude.
	OutputTokens int `json:"output_tokens"`

	// CacheReadInputTokens is the number of tokens read from cache.
	// Cached tokens are billed at a discounted rate.
	CacheReadInputTokens int `json:"cache_read_input_tokens,omitempty"`

	// CacheCreationInputTokens is the number of tokens used to create cache.
	CacheCreationInputTokens int `json:"cache_creation_input_tokens,omitempty"`
}

// TotalTokens returns the total number of tokens (input + output).
func (u *Usage) TotalTokens() int {
	if u == nil {
		return 0
	}
	return u.InputTokens + u.OutputTokens
}

// StreamEvent represents a raw JSON event from Claude's streaming output.
//
// This is the low-level structure that maps directly to Claude's stream-json format.
// Most users should work with [Event] instead, which provides parsed fields and
// convenience methods. StreamEvent is primarily used internally by [Parser] and
// is available via [Event.Raw] for cases where access to the original JSON
// structure is needed.
type StreamEvent struct {
	Type          string          `json:"type"`
	Subtype       string          `json:"subtype,omitempty"`
	Message       *MessageContent `json:"message,omitempty"`
	ToolUseResult *ToolResult     `json:"tool_use_result,omitempty"`
	Usage         *Usage          `json:"usage,omitempty"`
}

// MessageContent represents the content of a message in Claude's streaming output.
//
// A message may contain multiple [ContentBlock] items, typically text output
// and/or tool invocations. This structure appears in assistant-type events
// within [StreamEvent.Message].
type MessageContent struct {
	Content []ContentBlock `json:"content,omitempty"`
	Usage   *Usage         `json:"usage,omitempty"`
}

// ContentBlock represents a single block of content within a [MessageContent].
//
// The Type field indicates the kind of content:
//   - "text": Contains text output in the Text field
//   - "tool_use": Contains a tool invocation with ID, Name and Input fields
//   - "tool_result": Contains a tool result with ToolUseID and Content fields
//
// For text blocks, only Type and Text are populated. For tool_use blocks,
// Type, ID, Name, and Input are populated. For tool_result blocks,
// Type, ToolUseID, and Content are populated.
//
// InputRaw captures the raw JSON of the input field for unknown tools,
// allowing display of parameters even when they don't map to known ToolInput fields.
type ContentBlock struct {
	Type     string          `json:"type"`
	Text     string          `json:"text,omitempty"`
	Name     string          `json:"name,omitempty"`
	Input    *ToolInput      `json:"input,omitempty"`
	InputRaw json.RawMessage `json:"-"` // Raw JSON for unknown/future tools

	// ID is the unique identifier for tool_use blocks.
	// Used to correlate tool uses with their results.
	ID string `json:"id,omitempty"`

	// ToolUseID is the ID of the corresponding tool_use for tool_result blocks.
	// Matches the ID field from the tool_use block this result corresponds to.
	ToolUseID string `json:"tool_use_id,omitempty"`

	// Content is the result content for tool_result blocks.
	// Contains the output from the tool execution.
	Content string `json:"content,omitempty"`
}

// UnmarshalJSON implements custom unmarshaling to capture raw input JSON
// while still parsing known fields into ToolInput.
func (c *ContentBlock) UnmarshalJSON(data []byte) error {
	// First, unmarshal into a temporary struct to avoid recursion
	type contentBlockAlias ContentBlock
	var temp struct {
		contentBlockAlias
		InputRaw json.RawMessage `json:"input,omitempty"`
	}

	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	// Copy the basic fields
	c.Type = temp.Type
	c.Text = temp.Text
	c.Name = temp.Name
	c.ID = temp.ID
	c.ToolUseID = temp.ToolUseID
	c.Content = temp.Content

	// Store the raw input JSON
	c.InputRaw = temp.InputRaw

	// Parse known fields into ToolInput
	if len(temp.InputRaw) > 0 {
		c.Input = &ToolInput{}
		// Ignore errors - unknown fields will just be empty
		_ = json.Unmarshal(temp.InputRaw, c.Input)
	}

	return nil
}

// ToolInput represents the input parameters for a tool invocation.
//
// Different tools use different fields:
//   - Command: Used by bash/shell tools for the command to execute
//   - Description: Human-readable description of what the tool is doing
//   - FilePath: Used by file operations (read, write, edit) for the target path
//   - Content: Used by write operations for the content to write
//   - OldString: Used by Edit tool for the text to replace
//   - NewString: Used by Edit tool for the replacement text
//   - Pattern: Used by Glob and Grep for search patterns
//   - Query: Used by WebSearch for search queries
//   - URL: Used by WebFetch for the target URL
//   - Path: Used by Glob/Grep for the directory to search
//   - SubagentType: Used by Task tool for the type of subagent
//   - Prompt: Used by Task tool for the prompt to the subagent
//   - NotebookPath: Used by NotebookEdit for the notebook file path
//   - CellID: Used by NotebookEdit for the cell identifier
//   - NewSource: Used by NotebookEdit for the new cell content
//   - EditMode: Used by NotebookEdit for the edit operation type
//   - CellType: Used by NotebookEdit for the cell type (code/markdown)
//   - Questions: Used by AskUserQuestion for the questions to display
//   - Skill: Used by Skill tool for the skill name
//   - Args: Used by Skill tool for skill arguments
//
// All fields are optional; which fields are populated depends on the specific tool.
type ToolInput struct {
	// Common fields
	Command     string `json:"command,omitempty"`
	Description string `json:"description,omitempty"`
	FilePath    string `json:"file_path,omitempty"`
	Content     string `json:"content,omitempty"`
	OldString   string `json:"old_string,omitempty"`
	NewString   string `json:"new_string,omitempty"`
	Pattern     string `json:"pattern,omitempty"`
	Query       string `json:"query,omitempty"`
	URL         string `json:"url,omitempty"`
	Path        string `json:"path,omitempty"`

	// Task tool fields
	SubagentType string `json:"subagent_type,omitempty"`
	Prompt       string `json:"prompt,omitempty"`

	// NotebookEdit fields
	NotebookPath string `json:"notebook_path,omitempty"`
	CellID       string `json:"cell_id,omitempty"`
	NewSource    string `json:"new_source,omitempty"`
	EditMode     string `json:"edit_mode,omitempty"`
	CellType     string `json:"cell_type,omitempty"`

	// AskUserQuestion fields
	Questions []Question `json:"questions,omitempty"`

	// Skill tool fields
	Skill string `json:"skill,omitempty"`
	Args  string `json:"args,omitempty"`

	// TodoWrite fields
	Todos []TodoItem `json:"todos,omitempty"`
}

// TodoItem represents a single todo item in the TodoWrite tool.
type TodoItem struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Status     string `json:"status"`               // "pending", "in_progress", "completed"
	Priority   string `json:"priority,omitempty"`   // "high", "medium", "low"
	ActiveForm string `json:"activeForm,omitempty"` // Present continuous form for in_progress
}

// Question represents a question in the AskUserQuestion tool.
type Question struct {
	Question    string           `json:"question"`
	Header      string           `json:"header,omitempty"`
	Options     []QuestionOption `json:"options,omitempty"`
	MultiSelect bool             `json:"multiSelect,omitempty"`
}

// QuestionOption represents an option for a question.
type QuestionOption struct {
	Label       string `json:"label"`
	Description string `json:"description,omitempty"`
}

// ToolResult represents the result of a tool execution.
//
// This structure appears in user-type events within [StreamEvent.ToolUseResult]
// and contains the output from tool execution:
//   - Stdout: Standard output from the tool (e.g., command output)
//   - Stderr: Standard error output from the tool
//   - Interrupted: True if the tool execution was interrupted (e.g., timeout or cancellation)
//
// Either Stdout or Stderr (or both) may be populated depending on the tool's output.
type ToolResult struct {
	Stdout      string `json:"stdout,omitempty"`
	Stderr      string `json:"stderr,omitempty"`
	Interrupted bool   `json:"interrupted,omitempty"`
}

// EventType represents the type of event received from Claude's streaming output.
//
// Events flow through the stream in a typical order: system (init), then alternating
// assistant and user events, and finally a result event when the session completes.
type EventType string

const (
	// EventTypeSystem indicates a system event, typically session initialization.
	// Check [Event.SessionStarted] to detect the init subtype.
	EventTypeSystem EventType = "system"

	// EventTypeAssistant indicates output from Claude, either text or tool invocations.
	// Use [Event.IsText] and [Event.IsToolUse] to distinguish between content types.
	EventTypeAssistant EventType = "assistant"

	// EventTypeUser indicates tool execution results returned to Claude.
	// Use [Event.IsToolResult] to check if this event contains tool output.
	EventTypeUser EventType = "user"

	// EventTypeResult indicates the session has completed.
	// Check [Event.SessionComplete] which will be true for result events.
	EventTypeResult EventType = "result"
)

// SubtypeInit is the subtype value for system initialization events.
// When [Event.Type] is [EventTypeSystem] and [Event.Subtype] equals SubtypeInit,
// the Claude session has started.
const SubtypeInit = "init"

// Event is a parsed event from Claude's streaming output.
//
// This is the primary type that users interact with when processing Claude's output.
// It wraps the raw [StreamEvent] and extracts commonly needed fields into convenient
// top-level properties. Use the convenience methods [Event.IsText], [Event.IsToolUse],
// and [Event.IsToolResult] to quickly identify event types.
//
// Event is created by [NewEventFromStream] and emitted by [Parser.Parse].
type Event struct {
	// Raw provides access to the original [StreamEvent] for cases where
	// the parsed fields are insufficient.
	Raw *StreamEvent

	// Type is the parsed event type (system, assistant, user, or result).
	Type EventType

	// Subtype provides additional classification for certain event types.
	// For system events, this may be "init" (see [SubtypeInit]).
	Subtype string

	// Text contains the text content when Type is [EventTypeAssistant]
	// and the content block is of type "text". Empty otherwise.
	Text string

	// ToolID is the unique identifier for this tool invocation.
	// Used to correlate tool uses with their results.
	ToolID string

	// ToolUseID is the ID of the corresponding tool_use for tool_result events.
	// Matches the ToolID field from the tool_use event this result corresponds to.
	ToolUseID string

	// ToolName is the name of the tool being invoked when Type is
	// [EventTypeAssistant] and the content block is of type "tool_use".
	ToolName string

	// ToolDescription is a human-readable description of what the tool
	// is doing. Populated for tool_use events.
	ToolDescription string

	// ToolCommand is the command string for bash/shell tool invocations.
	ToolCommand string

	// ToolFilePath is the file path for file operation tools.
	ToolFilePath string

	// ToolPattern is the pattern for Glob/Grep tools.
	ToolPattern string

	// ToolQuery is the query for WebSearch tools.
	ToolQuery string

	// ToolURL is the URL for WebFetch tools.
	ToolURL string

	// ToolPath is the directory path for Glob/Grep tools.
	ToolPath string

	// ToolOldString is the text to replace for Edit tools.
	ToolOldString string

	// ToolNewString is the replacement text for Edit tools.
	ToolNewString string

	// ToolContent is the content for Write tools.
	ToolContent string

	// ToolInputRaw is the raw JSON input for unknown/future tools.
	ToolInputRaw json.RawMessage

	// Task tool fields
	ToolSubagentType string
	ToolPrompt       string

	// NotebookEdit fields
	ToolNotebookPath string
	ToolCellID       string
	ToolNewSource    string
	ToolEditMode     string
	ToolCellType     string

	// AskUserQuestion fields
	ToolQuestions []Question

	// Skill tool fields
	ToolSkill string
	ToolArgs  string

	// TodoWrite fields
	ToolTodos []TodoItem

	// ToolStdout contains the standard output from a tool execution.
	// Populated when Type is [EventTypeUser] and the event contains tool results.
	ToolStdout string

	// ToolStderr contains the standard error output from a tool execution.
	ToolStderr string

	// ToolInterrupted indicates whether tool execution was interrupted.
	ToolInterrupted bool

	// HasToolResult is true when this event is a tool result event,
	// regardless of whether stdout/stderr are empty.
	HasToolResult bool

	// SessionStarted is true for system init events, indicating the
	// Claude session has begun.
	SessionStarted bool

	// SessionComplete is true for result events, indicating the
	// Claude session has finished.
	SessionComplete bool

	// InputTokens is the number of input tokens in this event.
	// For assistant events, this is per-message. For result events,
	// this is the total for the session.
	InputTokens int

	// OutputTokens is the number of output tokens in this event.
	// For assistant events, this is per-message. For result events,
	// this is the total for the session.
	OutputTokens int
}

// NewEventFromStream creates an [Event] from a raw [StreamEvent].
//
// This function parses the StreamEvent and extracts relevant fields into the
// Event's convenience properties based on the event type. It handles all event
// types (system, assistant, user, result) and populates the appropriate fields.
func NewEventFromStream(raw *StreamEvent) Event {
	e := Event{
		Raw:     raw,
		Type:    EventType(raw.Type),
		Subtype: raw.Subtype,
	}

	switch e.Type {
	case EventTypeSystem:
		if raw.Subtype == SubtypeInit {
			e.SessionStarted = true
		}

	case EventTypeAssistant:
		if raw.Message != nil {
			// Extract token usage from message
			if raw.Message.Usage != nil {
				e.InputTokens = raw.Message.Usage.InputTokens
				e.OutputTokens = raw.Message.Usage.OutputTokens
			}
			// Extract content blocks
			for _, block := range raw.Message.Content {
				switch block.Type {
				case "text":
					e.Text = block.Text
				case "tool_use":
					e.ToolID = block.ID
					e.ToolName = block.Name
					// Store raw input for unknown tools
					e.ToolInputRaw = block.InputRaw
					if block.Input != nil {
						// Common fields
						e.ToolDescription = block.Input.Description
						e.ToolCommand = block.Input.Command
						e.ToolFilePath = block.Input.FilePath
						e.ToolOldString = block.Input.OldString
						e.ToolNewString = block.Input.NewString
						e.ToolPattern = block.Input.Pattern
						e.ToolQuery = block.Input.Query
						e.ToolURL = block.Input.URL
						e.ToolPath = block.Input.Path
						e.ToolContent = block.Input.Content

						// Task tool fields
						e.ToolSubagentType = block.Input.SubagentType
						e.ToolPrompt = block.Input.Prompt

						// NotebookEdit fields
						e.ToolNotebookPath = block.Input.NotebookPath
						e.ToolCellID = block.Input.CellID
						e.ToolNewSource = block.Input.NewSource
						e.ToolEditMode = block.Input.EditMode
						e.ToolCellType = block.Input.CellType

						// AskUserQuestion fields
						e.ToolQuestions = block.Input.Questions

						// Skill tool fields
						e.ToolSkill = block.Input.Skill
						e.ToolArgs = block.Input.Args

						// TodoWrite fields
						e.ToolTodos = block.Input.Todos
					}
				}
			}
		}

	case EventTypeUser:
		// Handle tool results from ToolUseResult field (verbose mode)
		if raw.ToolUseResult != nil {
			e.ToolStdout = raw.ToolUseResult.Stdout
			e.ToolStderr = raw.ToolUseResult.Stderr
			e.ToolInterrupted = raw.ToolUseResult.Interrupted
			e.HasToolResult = true
		}
		// Also handle tool_result content blocks (standard format)
		if raw.Message != nil {
			for _, block := range raw.Message.Content {
				if block.Type == "tool_result" {
					e.ToolUseID = block.ToolUseID
					// Content may contain the output
					if block.Content != "" && e.ToolStdout == "" {
						e.ToolStdout = block.Content
					}
					e.HasToolResult = true
				}
			}
		}

	case EventTypeResult:
		e.SessionComplete = true
		// Extract final token usage from result event
		if raw.Usage != nil {
			e.InputTokens = raw.Usage.InputTokens
			e.OutputTokens = raw.Usage.OutputTokens
		}
	}

	return e
}

// IsText returns true if this event contains text content from Claude.
//
// Use this method to filter for events where Claude is outputting text
// (as opposed to invoking tools). Returns true when Type is [EventTypeAssistant]
// and the Text field is non-empty.
func (e Event) IsText() bool {
	return e.Type == EventTypeAssistant && e.Text != ""
}

// IsToolUse returns true if this event represents a tool invocation by Claude.
//
// Use this method to detect when Claude is calling a tool. When true, the
// ToolName, ToolDescription, ToolCommand, and/or ToolFilePath fields will
// be populated depending on the specific tool being invoked.
func (e Event) IsToolUse() bool {
	return e.Type == EventTypeAssistant && e.ToolName != ""
}

// IsToolResult returns true if this event is a tool execution result.
//
// Use this method to detect tool execution results. When true, ToolStdout
// and/or ToolStderr may contain the tool's output (or be empty for tools
// with no output like TodoWrite). Check ToolInterrupted to determine if
// the tool was interrupted before completion.
func (e Event) IsToolResult() bool {
	return e.Type == EventTypeUser && e.HasToolResult
}
