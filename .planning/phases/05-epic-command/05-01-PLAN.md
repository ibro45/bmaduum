---
phase: 05-epic-command
plan: 01
type: execute
---

<objective>
Add `epic` command that batch-runs all non-done stories for an epic in numeric order with fail-fast behavior.

Purpose: Enable running an entire epic's stories with a single command, automatically routing each story to the appropriate workflow based on status.
Output: Working `bmad-automate epic <epic-id>` command with tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (from frontmatter dependency graph):

@.planning/phases/04-update-queue-command/04-01-SUMMARY.md
@.planning/phases/03-update-run-command/03-01-SUMMARY.md

# Key files to reference:

@internal/status/reader.go
@internal/status/types.go
@internal/cli/queue.go
@internal/workflow/queue.go
@internal/cli/root.go

**Tech stack available:** yaml.v3, Cobra, status.Reader, router.GetWorkflow
**Established patterns:**

- StatusReader injected via App struct
- Queue runner handles status-based routing with skip for done stories
- Queue command pattern: CLI creates command, calls Queue.RunQueueWithStatus()

**Constraining decisions:**

- Phase 4: Done stories in queue are skipped (continue), not terminal success
- Phase 3: StatusReader injected via App struct for testability
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetEpicStories method and epic command</name>
  <files>internal/status/reader.go, internal/cli/epic.go, internal/cli/root.go</files>
  <action>
1. Add `GetEpicStories(epicID string) ([]string, error)` method to status.Reader:
   - Read sprint status file
   - Filter keys matching pattern `{epicID}-{N}-*` where N is numeric
   - Sort by numeric story number (parse second segment as int)
   - Return sorted slice of story keys
   - Return error if no stories found for epic

2. Create `internal/cli/epic.go` with newEpicCommand(app \*App):
   - Use: "epic <epic-id>"
   - Short: "Run appropriate workflow for all stories in an epic"
   - Long description explaining: reads sprint-status.yaml, finds all stories matching epic ID, runs them in numeric order, stops on first failure, skips done stories
   - Args: cobra.ExactArgs(1)
   - RunE:
     - Get epic stories via app.StatusReader.GetEpicStories(args[0])
     - If error (no stories found), return ExitError(1)
     - Call app.Queue.RunQueueWithStatus(ctx, storyKeys, app.StatusReader)
     - Return ExitError if non-zero exit code

3. Add newEpicCommand(app) to root.go AddCommand list
   </action>
   <verify>
   go build ./... compiles without errors
   go test ./internal/status/... passes
   </verify>
   <done>

- GetEpicStories returns sorted story keys for an epic
- epic command registered and callable
- Build succeeds
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for epic command</name>
  <files>internal/status/reader_test.go, internal/cli/epic_test.go</files>
  <action>
1. Add tests to internal/status/reader_test.go for GetEpicStories:
   - Test returns stories matching epic ID sorted by story number
   - Test filters out stories from other epics
   - Test returns error when no stories found
   - Test handles numeric sorting (2 before 10)

2. Create internal/cli/epic_test.go with tests:
   - Use setupQueueTestApp pattern from queue_test.go (it already has StatusReader)
   - TestEpicCommand_FindsAndRunsEpicStories: epic with 3 stories runs all 3
   - TestEpicCommand_NumericSorting: stories 1, 2, 10 run in order 1, 2, 10 (not 1, 10, 2)
   - TestEpicCommand_SkipsDoneStories: epic with mix of statuses skips done
   - TestEpicCommand_StopsOnFailure: uses failing MockExecutor, verifies early exit
   - TestEpicCommand_NoStoriesFound: returns exit code 1
   - TestEpicCommand_MissingSprintStatusFile: returns exit code 1
     </action>
     <verify>
     go test ./internal/status/... -v passes
     go test ./internal/cli/... -v passes
     </verify>
     <done>

- GetEpicStories has tests for filtering, sorting, edge cases
- epic command has tests for all scenarios
- All tests pass
  </done>
  </task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./...` passes all tests
- [ ] `go vet ./...` reports no issues
- [ ] epic command appears in `bmad-automate --help`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Epic command finds stories by epic ID, sorts numerically, runs with status-based routing
- Fail-fast behavior (stops on first failure)
- Done stories skipped (inherited from queue behavior)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-epic-command/05-01-SUMMARY.md` following summary.md template.
</output>
