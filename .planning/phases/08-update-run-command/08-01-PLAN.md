---
phase: 08-update-run-command
plan: 01
type: tdd
domain: go-cli
---

<objective>
Update `run` command to execute full story lifecycle instead of single workflow.

Purpose: Enable `run <story>` to complete a story entirely (create→dev→review→commit→done) by using the lifecycle executor.
Output: `run` command uses lifecycle.Executor, with updated tests verifying full lifecycle execution.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary-frontmatter.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency chain):

@.planning/phases/06-lifecycle-definition/06-01-SUMMARY.md
@.planning/phases/07-story-lifecycle-executor/07-01-SUMMARY.md
@.planning/phases/07-story-lifecycle-executor/07-02-SUMMARY.md

# Current implementation:

@internal/cli/run.go
@internal/cli/run_test.go
@internal/cli/root.go
@internal/lifecycle/executor.go
@internal/status/writer.go

**Tech stack available:**

- lifecycle.Executor orchestrates full story lifecycle
- status.Writer for updating sprint-status.yaml
- workflow.Runner already satisfies WorkflowRunner interface
- status.Reader already satisfies StatusReader interface
- status.Writer already satisfies StatusWriter interface

**Established patterns:**

- Interface-based dependency injection via App struct
- TDD with table-driven tests
- Fail-fast execution on errors

**Constraining decisions:**

- [Phase 7-02]: lifecycle.Executor.Execute() runs full lifecycle, returns error on failure
- [Phase 7-02]: Returns router.ErrStoryComplete for done stories
- [Phase 7-01]: StatusWriter uses atomic writes via temp file + rename
  </context>

<feature>
  <name>Run command with full lifecycle execution</name>
  <files>internal/cli/run.go, internal/cli/run_test.go, internal/cli/root.go</files>
  <behavior>
    `run <story-key>` should:
    1. Create lifecycle.Executor with App dependencies
    2. Call executor.Execute(ctx, storyKey)
    3. Return exit code 0 on success
    4. Return exit code 1 on error (except ErrStoryComplete)
    5. Print "Story X is already complete" for done stories (existing behavior)

    Cases:
    - Story from backlog → runs 4 workflows → status updated to done → exit 0
    - Story from ready-for-dev → runs 3 workflows → status updated to done → exit 0
    - Story from review → runs 2 workflows → status updated to done → exit 0
    - Story already done → prints message → exit 0
    - Workflow fails mid-lifecycle → error → exit 1
    - Status update fails → error → exit 1
    - Story not found → error → exit 1

  </behavior>
  <implementation>
    1. Add StatusWriter *status.Writer to App struct in root.go
    2. Initialize StatusWriter in NewApp() with status.NewWriter("")
    3. In run.go: Create lifecycle.Executor with app.Runner, app.StatusReader, app.StatusWriter
    4. Call executor.Execute(ctx, storyKey)
    5. Handle errors: ErrStoryComplete → print and return nil, other errors → exit 1
    6. Update tests to verify full lifecycle execution with mock dependencies
  </implementation>
</feature>

<verification>
- [ ] `go test ./internal/cli/... -v` - all tests pass
- [ ] `go build ./...` - builds without errors
- [ ] `go vet ./...` - no issues
</verification>

<success_criteria>

- Run command uses lifecycle.Executor
- App struct has StatusWriter field
- Tests verify full lifecycle execution (multiple workflows run)
- Tests verify status updates occur after each workflow
- Tests verify fail-fast on errors
- All 2-3 TDD commits present
  </success_criteria>

<output>
After completion, create `.planning/phases/08-update-run-command/08-01-SUMMARY.md` with:
- RED: What test was written, why it failed
- GREEN: What implementation made it pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
