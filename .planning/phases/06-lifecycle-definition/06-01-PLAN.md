---
phase: 06-lifecycle-definition
plan: 01
type: tdd
---

<objective>
Define the full workflow sequence per status and status transitions for story lifecycle.

Purpose: Enable executing the complete story lifecycle (create→dev→review→commit→done) by defining what workflows run and what status transitions occur.
Output: Extended router package with lifecycle sequence types and GetLifecycle function.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-workflow-router/02-01-SUMMARY.md

# Key files from prior phases:

@internal/router/router.go
@internal/router/router_test.go
@internal/status/types.go
@config/workflows.yaml

**Tech stack available:** gopkg.in/yaml.v3
**Established patterns:** table-driven-tests, switch-statement-routing, sentinel-errors

**Constraining decisions:**

- [Phase 2]: Package-level function instead of struct (pure mapping, no state needed)
- [Phase 2]: Sentinel errors for errors.Is() compatibility

**Phase 6 Requirements (from ROADMAP):**

- Add `git-commit` to the workflow chain after `code-review`
- Define status transitions: create→ready-for-dev, dev→review, review→done
- Update router package with lifecycle sequence logic
  </context>

<feature>
  <name>Story Lifecycle Sequence</name>
  <files>internal/router/lifecycle.go, internal/router/lifecycle_test.go</files>
  <behavior>
    GetLifecycle(status) returns the sequence of LifecycleStep from current status to done.

    Each LifecycleStep contains:
    - Workflow: the workflow to execute
    - NextStatus: the status to transition to after workflow completes

    Cases:
    - backlog → [(create-story, ready-for-dev), (dev-story, review), (code-review, done), (git-commit, done)]
    - ready-for-dev → [(dev-story, review), (code-review, done), (git-commit, done)]
    - in-progress → [(dev-story, review), (code-review, done), (git-commit, done)]
    - review → [(code-review, done), (git-commit, done)]
    - done → ErrStoryComplete (no steps needed)
    - unknown → ErrUnknownStatus

    Note: git-commit doesn't change status (story is already done after code-review), but is still part of the lifecycle sequence. Both code-review and git-commit have NextStatus=done.

  </behavior>
  <implementation>
    Create lifecycle.go with:
    1. LifecycleStep struct { Workflow string, NextStatus status.Status }
    2. GetLifecycle(s status.Status) ([]LifecycleStep, error) function
    3. Use switch statement matching existing GetWorkflow pattern
    4. Return slices of LifecycleStep for each starting status
    5. Reuse ErrStoryComplete and ErrUnknownStatus from router.go
  </implementation>
</feature>

<verification>
go test ./internal/router/... -v
go build ./...
</verification>

<success_criteria>

- Failing test written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All tests pass: go test ./internal/router/...
- Build passes: go build ./...
  </success_criteria>

<output>
After completion, create `.planning/phases/06-lifecycle-definition/06-01-SUMMARY.md`:

# Phase 6 Plan 01: Story Lifecycle Sequence Summary

**[Substantive one-liner describing what shipped]**

## Performance

- Duration: X min
- Tasks: RED → GREEN (→ REFACTOR if needed)

## Accomplishments

- LifecycleStep type defined
- GetLifecycle function implemented
- Full test coverage for all status values

## Files Created/Modified

- `internal/router/lifecycle.go` - LifecycleStep, GetLifecycle
- `internal/router/lifecycle_test.go` - TestGetLifecycle

## Decisions Made

- [Document any decisions]

## Deviations from Plan

- [None or describe]

## Issues Encountered

- [None or describe]

## Next Phase Readiness

- Lifecycle definition complete
- Ready for Phase 7 (Story Lifecycle Executor) to use GetLifecycle
  </output>
